#pragma kernel SurfaceFront
#pragma kernel SurfaceBack
#pragma kernel Volume
#pragma kernel BuildTexture3D

#include "UnityCG.cginc"
#include "./Voxel.hlsl"

CBUFFER_START(VoxelParams)

CBUFFER_END

StructuredBuffer<float3> cb_verts;
StructuredBuffer<float2> cb_uv;
StructuredBuffer<int> cb_triangles;
RWStructuredBuffer<Voxel> cb_voxell;

uniform int _totalVerts;
uniform int _width, _height, _depth;
uniform float3 _start, _end, _size;
uniform float _unit, _invUnit, _halfUnit;

struct AABB
{
  float3 minCoor;
  float3 maxCoor;
  float3 center;
};

struct Plane
{
  float3 normal;
  float distance;
};

// https://gamedev.stackexchange.com/questions/23743/whats-the-most-efficient-way-to-find-barycentric-coordinates
void tri_barycentric(float3 p, float3 a, float3 b, float3 c, out float u, out float v, out float w)
{
  float3 v0 = b - a, v1 = c - a, v2 = p - a;
  float d00 = dot(v0, v0);
  float d01 = dot(v0, v1);
  float d11 = dot(v1, v1);
  float d20 = dot(v2, v0);
  float d21 = dot(v2, v1);
  float denom = 1.0 / (d00 * d11 - d01 * d01);
  v = (d11 * d20 - d01 * d21) * denom;
  w = (d00 * d21 - d01 * d20) * denom;
  u = 1.0f - v - w;
}

float2 tri_barycentric_uv(float3 p, float3 v0, float3 v1, float3 v2, float2 uv0, float2 uv1, float2 uv2)
{
  float u, v, w;
  tri_barycentric(p, v0, v1, v2, u, v, w);
  return uv0 * u + uv1 * v + uv2 * w;
}

// check intersection between the triangle (v0, v1, v2) and AABB (extents) with projection onto the axis
bool intersects_tri_aabb_onto_axis(float3 v0, float3 v1, float3 v2, float3 extents, float3 axis)
{
  // project all 3 vertices of the triangle onto the axis
  float p0 = dot(v0, axis);
  float p1 = dot(v1, axis);
  float p2 = dot(v2, axis);

  // project the AABB onto the axis
  float r = extents.x * abs(axis.x) + extents.y * abs(axis.y) + extents.z * abs(axis.z);
  float minP = min(p0, min(p1, p2));
  float maxP = max(p0, max(p1, p2));
  return !((maxP < -r) || (r < minP));
}

bool intersects_plane_aabb(Plane pl, AABB aabb)
{
  float3 center = aabb.center;
  float3 extents = aabb.maxCoor - center;

  float r = extents.x * abs(pl.normal.x) + extents.y * abs(pl.normal.y) + extents.z * abs(pl.normal.z);
  float s = dot(pl.normal, center) - pl.distance;

  return abs(s) <= r;
}

bool intersects_tri_aabb(float3 v0, float3 v1, float3 v2, AABB aabb)
{
  float p0, p1, p2, r;

  float3 center = aabb.center, extents = aabb.maxCoor - center;

  // translate the triangle as conceptually moving the AABB to origin
  v0 -= center;
  v1 -= center;
  v2 -= center;

  // compute the edge vectors of the triangle
  // get the lines between the points as vectors
  float3 f0 = v1 - v0,
  f1 = v2 - v1,
  f2 = v0 - v2;

  // cross products of triangle edges & aabb edges
  // AABB normals are the x (1, 0, 0), y (0, 1, 0), z (0, 0, 1) axis.
  // so we can get the cross products between triangle edge vectors and AABB normals without calculation
  float3 a00 = float3(0, -f0.z, f0.y), // cross product of X and f0
  a01 = float3(0, -f1.z, f1.y), // X and f1
  a02 = float3(0, -f2.z, f2.y), // X and f2
  a10 = float3(f0.z, 0, -f0.x), // Y and f0
  a11 = float3(f1.z, 0, -f1.x), // Y and f1
  a12 = float3(f2.z, 0, -f2.x), // Y and f2
  a20 = float3(-f0.y, f0.x, 0), // Z and f0
  a21 = float3(-f1.y, f1.x, 0), // Z and f1
  a22 = float3(-f2.y, f2.x, 0); // Z and f2

  // Test 9 axes
  if (
    !intersects_tri_aabb_onto_axis(v0, v1, v2, extents, a00) ||
    !intersects_tri_aabb_onto_axis(v0, v1, v2, extents, a01) ||
    !intersects_tri_aabb_onto_axis(v0, v1, v2, extents, a02) ||
    !intersects_tri_aabb_onto_axis(v0, v1, v2, extents, a10) ||
    !intersects_tri_aabb_onto_axis(v0, v1, v2, extents, a11) ||
    !intersects_tri_aabb_onto_axis(v0, v1, v2, extents, a12) ||
    !intersects_tri_aabb_onto_axis(v0, v1, v2, extents, a20) ||
    !intersects_tri_aabb_onto_axis(v0, v1, v2, extents, a21) ||
    !intersects_tri_aabb_onto_axis(v0, v1, v2, extents, a22)
  )
  {
    return false;
  }

  // Test x axis
  if (max(v0.x, max(v1.x, v2.x)) < -extents.x || min(v0.x, min(v1.x, v2.x)) > extents.x)
  {
    return false;
  }

  // Test y axis
  if (max(v0.y, max(v1.y, v2.y)) < -extents.y || min(v0.y, min(v1.y, v2.y)) > extents.y)
  {
    return false;
  }

  // Test z axis
  if (max(v0.z, max(v1.z, v2.z)) < -extents.z || min(v0.z, min(v1.z, v2.z)) > extents.z)
  {
    return false;
  }

  // Test triangle normal
  Plane pl;
  pl.normal = normalize(cross(f1, f0));
  pl.distance = dot(pl.normal, v0);
  return intersects_plane_aabb(pl, aabb);
}

inline int get_voxel_index(int x, int y, int z)
{
  return z * (_width * _height) + y * _width + x;
}

inline float3 get_voxel_position(int x, int y, int z)
{
  return float3(
    _start.x + _unit * x + _halfUnit,
    _start.y + _unit * y + _halfUnit,
    _start.z + _unit * z + _halfUnit
  );
}

void GetTriangle(
  int idx, 
  out float3 v0, out float3 v1, out float3 v2, 
  out float2 uv0, out float2 uv1, out float2 uv2,
  out bool frontFace
)
{
  int ia = cb_triangles[idx * 3];
  int ib = cb_triangles[idx * 3 + 1];
  int ic = cb_triangles[idx * 3 + 2];

  v0 = cb_verts[ia];
  v1 = cb_verts[ib];
  v2 = cb_verts[ic];

  uv0 = cb_uv[ia];
  uv1 = cb_uv[ib];
  uv2 = cb_uv[ic];

  float3 normal = cross((v1 - v0), (v2 - v1));
  frontFace = dot(normal, float3(0, 0, 1)) < 0;
}

void Surface(
  float3 v0, float3 v1, float3 v2,
  float2 uv0, float2 uv1, float2 uv2,
  bool frontFace
)
{
  float3 tbmin = min(min(v0, v1), v2);
  float3 tbmax = max(max(v0, v1), v2);

  float3 bmin = tbmin - _start;
  float3 bmax = tbmax - _start;
  int iminX = round(bmin.x / _unit), iminY = round(bmin.y / _unit), iminZ = round(bmin.z / _unit);
  int imaxX = round(bmax.x / _unit), imaxY = round(bmax.y / _unit), imaxZ = round(bmax.z / _unit);

  iminX = clamp(iminX, 0, _width - 1);
  iminY = clamp(iminY, 0, _height - 1);
  iminZ = clamp(iminZ, 0, _depth - 1);
  imaxX = clamp(imaxX, 0, _width - 1);
  imaxY = clamp(imaxY, 0, _height - 1);
  imaxZ = clamp(imaxZ, 0, _depth - 1);

  for (int x = iminX; x <= imaxX; x++)
  {
    for (int y = iminY; y <= imaxY; y++)
    {
      for (int z = iminZ; z <= imaxZ; z++)
      {
        float3 center = float3(x, y, z) * _unit + _start;
        AABB aabb;
        aabb.minCoor = center - _halfUnit;
        aabb.center = center;
        aabb.maxCoor = center + _halfUnit;
        if (intersects_tri_aabb(v0, v1, v2, aabb))
        {
          uint vid = get_voxel_index(x, y, z);
          Voxel voxel = cb_voxell[vid];
          voxel.position = get_voxel_position(x, y, z);
          voxel.uv = tri_barycentric_uv(voxel.position, v0, v1, v2, uv0, uv1, uv2);
          voxel.frontFace = frontFace;
          voxel.fill = true;
          cb_voxell[vid] = voxel;
        }
      }
    }
  }
}

[numthreads(8, 1, 1)]
void SurfaceFront (uint3 id : SV_DispatchThreadID)
{
  int idx = (int)id.x;
  if(idx >= _totalVerts) return;

  float3 v0, v1, v2;
  float2 uv0, uv1, uv2;
  bool frontFace;
  GetTriangle(idx, v0, v1, v2, uv0, uv1, uv2, frontFace);

  if (!frontFace) return;
  Surface(v0, v1, v2, uv0, uv1, uv2, frontFace);
}

[numthreads(8, 1, 1)]
void SurfaceBack (uint3 id : SV_DispatchThreadID)
{
  int idx = (int)id.x;
  if(idx >= _totalVerts) return;

  float3 v0, v1, v2;
  float2 uv0, uv1, uv2;
  bool frontFace;
  GetTriangle(idx, v0, v1, v2, uv0, uv1, uv2, frontFace);

  if (frontFace) return;
  Surface(v0, v1, v2, uv0, uv1, uv2, frontFace);
}

[numthreads(8, 8, 1)]
void Volume (uint3 id : SV_DispatchThreadID)
{
  int x = (int)id.x;
  int y = (int)id.y;
  if(x >= _width) return;
  if(y >= _height) return;

  for (int z = 0; z < _depth; z++)
  {
    Voxel voxel = cb_voxell[get_voxel_index(x, y, z)];
    if (!voxel.fill) continue;

    int ifront = z;
    float2 uv = voxel.uv;
    for (; ifront < _depth; ifront++) {
      int vid = get_voxel_index(x, y, ifront);
      if (!is_front_voxel(cb_voxell[vid])) {
        break;
      }
      uv = cb_voxell[vid].uv;
    }

    if(ifront >= _depth) return;

    int iback = ifront;

    // step forward to empty
    for (; iback < _depth &&  is_empty_voxel(cb_voxell[get_voxel_index(x, y, iback)]); iback++) {}

    if (iback >= _depth) return;

    // check if iback is back voxel
    if (is_back_voxel(cb_voxell[get_voxel_index(x, y, iback)])) {
      // step forward to back face
      for (; iback < _depth && is_back_voxel(cb_voxell[get_voxel_index(x, y, iback)]); iback++) {}
    }

    // fill from ifront to iback
    for(int z2 = ifront; z2 < iback; z2++)
    {
      Voxel v;
      v.position = get_voxel_position(x, y, z2);
      v.uv = uv;
      v.fill = true;
      v.frontFace = false;
      cb_voxell[get_voxel_index(x, y, z2)] = v;
    }

    z = iback;
  }

}

RWTexture3D<float4> cb_voxelTexture;
Texture2D<float4> cb_colorTexture;
uniform SamplerState _pointRepeat;
uniform SamplerState _linearRepeat;

[numthreads(8, 8, 8)]
void BuildTexture3D (uint3 id : SV_DispatchThreadID)
{
  int x = (int)id.x;
  int y = (int)id.y;
  int z = (int)id.z;

  if(x >= _width) return;
  if(y >= _height) return;
  if(z >= _depth) return;

  uint vid = get_voxel_index(x, y, z);
  Voxel v = cb_voxell[vid];
  cb_voxelTexture[id] = lerp(float4(0, 0, 0, 0), cb_colorTexture.SampleLevel(_linearRepeat, v.uv, 0), v.fill ? 1.0 : 0.0);
}
